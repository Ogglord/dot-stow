#!/bin/bash

set -u 
set -Euo pipefail
trap cleanup EXIT

## dot specific functions
setup_colors() {
  if [[ -t 2 ]] && [[ -z "${NO_COLOR-}" ]] && [[ "${TERM-}" != "dumb" ]]; then
    NOFORMAT='\033[0m' RED='\033[0;31m' GREEN='\033[0;32m' ORANGE='\033[0;33m' BLUE='\033[0;34m' PURPLE='\033[0;35m' CYAN='\033[0;36m' YELLOW='\033[1;33m'
  else
    NOFORMAT='' RED='' GREEN='' ORANGE='' BLUE='' PURPLE='' CYAN='' YELLOW=''
  fi
}

function ask_yes_or_no() {
    if [[ "on" == "${_arg_force:-}" ]]; then
      echo "yes"
    else
      read -rp "$1 ([y]es or [N]o): "
      case $(echo "$REPLY" | tr '[:upper]' '[:lower]') in
          y|yes) echo "yes" ;;
          *)     echo "no" ;;
      esac
    fi
}

msg() {
  echo >&2 -e "${_print_indent}${1-}"
}

debug() {
  if [ "$_arg_verbose" == "on" ]; then
    echo >&2 -e "${_print_indent}${1-}"
  fi
}

# print two columns
msg2() {
  echo >&2 -e "${_print_indent}${1-}\t\t\t: ${2-}" | expand -t 30  
}

cleanup() {
  ## reset any popd
  debug "cleanup triggered (exit: $?) ..."
  pushd -0 > /dev/null && dirs -c > /dev/null
  trap - SIGINT SIGTERM ERR EXIT
  # script cleanup here
}

read_config_variable(){
  local KEY=$1
  local DEF=$2
  ret=$(git config -f "$DOT_CONFIG_FILE" "$KEY")
  debug "$KEY == ${ret:=$DEF}"
  echo "${ret}"

}

load_config(){
    local DOT_CONFIG_DIR="${DOT_CONFIG_DIR:-$HOME/.config/dot}"
    export DOT_CONFIG_FILE="$DOT_CONFIG_DIR/dot.config"
    debug "Config: $DOT_CONFIG_FILE"
    [[ ! -f "$DOT_CONFIG_FILE" ]] && msg "${RED}Config file is missing, re-run \`install.sh\`?${NOFORMAT}"
    ## loading each key
    git_remote=$(read_config_variable "git.dotfiles.remote" "origin")    
    git_branch=$(read_config_variable "git.dotfiles.branch" "main")
    target_dir=$(read_config_variable "path.target" "$HOME")    
    dotfiles_dir=$(read_config_variable "path.dotfiles" "${HOME}/.dotfiles")    
    stowcmd=$(read_config_variable "path.stow" "/usr/bin/stow")
    calling_dir="$PWD"
}


### START OF CODE GENERATED BY Argbash v2.9.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info
# Generated online by https://argbash.io/generate
#
# # When called, the process ends.
# Args:
#   $1: The exit message (print to stderr)
#   $2: The exit code (default is 1)
# if env var _PRINT_HELP is set to 'yes', the usage is print to stderr (prior to $1)
# Example:
#   test -f "$_arg_infile" || _PRINT_HELP=yes die "Can't continue, have to supply file as an argument, got '$_arg_infile'" 4
die()
{
  local _ret="${2:-1}"
  test "${_PRINT_HELP:-no}" = yes && print_help >&2
  echo -e "${RED}$1${NOFORMAT}" >&2
  exit "${_ret}"
}

# Function that evaluates whether a value passed to it begins by a character
# that is a short option of an argument the script knows about.
# This is required in order to support getopts-like short options grouping.
begins_with_short_option()
{
  local first_option all_short_options='nfphv'
  first_option="${1:0:1}"
  test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
# The positional args array has to be reset before the parsing, because it may already be defined
# - for example if this script is sourced by an argbash-powered script.
_positionals=()
_arg_arg=()
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_dry_run="off"
_arg_force="off"
_arg_package=
_arg_verbose="off"


# Function that prints general usage of the script.
# This is useful if users asks for it, or if there is an argument parsing error (unexpected / spurious arguments)
# and it makes sense to remind the user how the script is supposed to be called.
print_help()
{
  printf '%s\n' "Helps move, and stow dotfiles using GNU Stow and push/pull changes to git."
  printf '%s\n' "Use with caution."
  printf 'Usage: %s [-n|--(no-)dry-run] [-f|--(no-)force] [-v|--(no-)verbose] [-p|--package <package_name>] [-h|--help] [-V|--version] [--] <command> [<arg-1>] ... [<arg-n>] ...\n' "$0"
  printf '\t%s\n' "<command>: Which command to execute"
  printf '\t %s   \t%s\n' "add " "Move file(s) specified in <arg-n> to stow package --package/-p <package_name>"
  printf '\t %s   \t%s\n' "sync" "Performs local commit=>pull=>push=>restow to make sure local and remote are up-to-date"
  printf '\t %s   \t%s\n' "pull" "Pull changes from git"
  printf '\t %s   \t%s\n' "push" "Commit and push local changes to git"
  printf '\t %s   \t%s\n' "restow" "Update symlinks using stow. E.g. dot restow <package-1> ... <package-n>"  
  printf '\t %s   \t%s\n' "status" "Shows git status for the dotfiles"  
  printf '\t %s   \t%s\n' "update" "Run self updater for dot"
  printf "\n"
  printf '\t%s\n' "<arg>: Files/Directories or Packages to process"
  printf '\t%s\n' "-n, --dry-run, --no-dry-run: Do not write changes to disk/git (off by default)"
  printf '\t%s\n' "-f, --force, --no-force: Force changes, overwrite existing files and answers yes to prompts (off by default)"
  printf '\t%s\n' "-v, --verbose, --no-verbose: Verbose (off by default)"
  printf '\t%s\n' "-p, --package: Specify stow package (no default)"
  printf '\t%s\n' "-h, --help: Prints help"
  printf '\t%s\n' "-V, --version: Prints version"
}


# The parsing of the command-line
parse_commandline()
{
  _positionals_count=0
  while test $# -gt 0
  do
    _key="$1"
    # If two dashes (i.e. '--') were passed on the command-line,
    # assign the rest of arguments as positional arguments and bail out.
    if test "$_key" = '--'
    then
      shift
      # Handle the case when the double dash is the last argument.
      test $# -gt 0 || break
      _positionals+=("$@")
      _positionals_count=$((_positionals_count + $#))
      shift $(($# - 1))
      _last_positional="$1"
      break
    fi
    case "$_key" in
      # The dry-run argurment doesn't accept a value,
      # we expect the --dry-run or -n, so we watch for them.
      -n|--no-dry-run|--dry-run)
        _arg_dry_run="on"
        test "${1:0:5}" = "--no-" && _arg_dry_run="off"
        ;;
      # We support getopts-style short arguments clustering,
      # so as -n doesn't accept value, other short options may be appended to it, so we watch for -n*.
      # After stripping the leading -n from the argument, we have to make sure
      # that the first character that follows coresponds to a short option.
      -n*)
        _arg_dry_run="on"
        _next="${_key##-n}"
        if test -n "$_next" -a "$_next" != "$_key"
        then
          { begins_with_short_option "$_next" && shift && set -- "-n" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
        fi
        ;;
      # See the comment of option '--dry-run' to see what's going on here - principle is the same.
      -f|--no-force|--force)
        _arg_force="on"
        test "${1:0:5}" = "--no-" && _arg_force="off"
        ;;
      # See the comment of option '-n' to see what's going on here - principle is the same.
      -f*)
        _arg_force="on"
        _next="${_key##-f}"
        if test -n "$_next" -a "$_next" != "$_key"
        then
          { begins_with_short_option "$_next" && shift && set -- "-f" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
        fi
        ;;
      # See the comment of option '--dry-run' to see what's going on here - principle is the same.
      -v|--no-verbose|--verbose)
        _arg_verbose="on"
        test "${1:0:5}" = "--no-" && _arg_verbose="off"
        ;;
      # See the comment of option '-n' to see what's going on here - principle is the same.
      -v*)
        _arg_verbose="on"
        _next="${_key##-v}"
        if test -n "$_next" -a "$_next" != "$_key"
        then
          { begins_with_short_option "$_next" && shift && set -- "-v" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
        fi
        ;;
      # We support whitespace as a delimiter between option argument and its value.
      # Therefore, we expect the --package or -p value.
      # so we watch for --package and -p.
      # Since we know that we got the long or short option,
      # we just reach out for the next argument to get the value.
      -p|--package)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_package="$2"
        shift
        ;;
      # We support the = as a delimiter between option argument and its value.
      # Therefore, we expect --package=value, so we watch for --package=*
      # For whatever we get, we strip '--package=' using the ${var##--package=} notation
      # to get the argument value
      --package=*)
        _arg_package="${_key##--package=}"
        ;;
      # We support getopts-style short arguments grouping,
      # so as -p accepts value, we allow it to be appended to it, so we watch for -p*
      # and we strip the leading -p from the argument string using the ${var##-p} notation.
      -p*)
        _arg_package="${_key##-p}"
        ;;
      # See the comment of option '--dry-run' to see what's going on here - principle is the same.
      -h|--help)
        print_help
        exit 0
        ;;
      # See the comment of option '-n' to see what's going on here - principle is the same.
      -h*)
        print_help
        exit 0
        ;;
      # See the comment of option '--dry-run' to see what's going on here - principle is the same.
      -V|--version)
        echo "$(basename $0) (dot by Ogglord) v0.1"
        exit 0
        ;;
      # See the comment of option '-n' to see what's going on here - principle is the same.
      -V*)
        echo $0 v0.1
        exit 0
        ;;
      *)
        _last_positional="$1"
        _positionals+=("$_last_positional")
        _positionals_count=$((_positionals_count + 1))
        ;;
    esac
    shift
  done
}


# Check that we receive expected amount positional arguments.
# Return 0 if everything is OK, 1 if we have too little arguments
# and 2 if we have too much arguments
handle_passed_args_count()
{
  local _required_args_string="'command'"
  ##test "${_positionals_count}" -ge 1 || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require at least 1 (namely: $_required_args_string), but got only ${_positionals_count}." 1
  test "${_positionals_count}" -ge 1 || _PRINT_HELP=yes die "FATAL ERROR: Missing $_required_args_string (got only ${_positionals_count} arguments)." 1
# We accept up to inifinitely many positional values, so
# there is no need to check for spurious positional arguments.
}


# Take arguments that we have received, and save them in variables of given names.
# The 'eval' command is needed as the name of target variable is saved into another variable.
assign_positional_args()
{
  local _positional_name _shift_for=$1
  # We have an array of variables to which we want to save positional args values.
  # This array is able to hold array elements as targets.
  # As variables don't contain spaces, they may be held in space-separated string.
  _positional_names="_arg_command "
  # If we allow up to infinitely many args, we calculate how many of values
  # were actually passed, and we extend the target array accordingly.
  # We also know that we have _pos_names_count known positional arguments.
  _our_args=$((${#_positionals[@]} - 1))
  for ((ii = 0; ii < _our_args; ii++))
  do
    _positional_names="$_positional_names _arg_arg[$((ii + 0))]"
  done

  shift "$_shift_for"
  for _positional_name in ${_positional_names}
  do
    test $# -gt 0 || break
    eval "$_positional_name=\${1}" || die "Error during argument parsing, possibly an Argbash bug." 1
    shift
  done
}

# Now call all the functions defined above that are needed to get the job done
setup_colors
parse_commandline "$@"
handle_passed_args_count
assign_positional_args 1 "${_positionals[@]}"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])

_print_indent="\t"
debug "${YELLOW}- Verbose -"
debug "${YELLOW}dry run is $_arg_dry_run"
debug "${YELLOW}force is $_arg_force"
debug "${YELLOW}Value of command: $_arg_command"
debug "${YELLOW}Value of package: $_arg_package"
debug "${YELLOW}Value of args: ${_arg_arg[*]}"
debug "${YELLOW}Number of args: ${#_arg_arg[*]}"

load_config ## this might print some settings too

debug "${NOFORMAT}"
_print_indent=""

###################
#########  HELPER FUNCTIONS   ##########
###################


## usage if isSubPath "/root" "/folder/to/test" ;then ...
isSubPath() {
  if [[ $(realpath --relative-base="$1" -- "$2")  =~ ^/ ]]
    then return 1 # false
    else return 0 # true
  fi
}
get_path_rel_caller()
{
  # check if absolute or relative to calling_dir
  if [[ "$1" = /* ]]; then
     echo "$1"
  else
     echo "${calling_dir%%/}${calling_dir:+/}$1"
  fi
 
}

get_package_root()
{
   local dir="${dotfiles_dir%%/}${dotfiles_dir:+/}$1"
   mkdir -p "$dir"
   echo "$dir"
}

# usage get_path_rel_package "package" "/home/username/.local/package/config.toml"
# returns the path where to stow this file/dir, e.g ~/.dotfiles/package/.local/package/config.toml
get_path_rel_package()
{
   local _pkg_root
   local _original_dir
   local _stow_filename
   local _package_path
   local _stow_dir

   _pkg_root="$1"
   _original_dir="$(dirname "$2")"
   _stow_filename="$(basename "$2")"
   _package_path=$(realpath --relative-base="${target_dir}" "${_original_dir}")
   _stow_dir="${_pkg_root}/${_package_path}"

   ## make sure dir exists
   mkdir -p "${_stow_dir}"

   #calculate full stow path
   local _stow_path="${_stow_dir%%/}${_stow_dir:+/}${_stow_filename}"
   echo "${_stow_path}"
}

#######################################
### COMMANDS START HERE
#######################################
add()
{
  all_found=1
 
  ## this command requires package to be specified
  [[ -z "${_arg_package-}" ]] && die "Missing required parameter: package"

  package_root=$(get_package_root "$_arg_package")
  msg "Adding files to stow packet at ${package_root}"

  ## each arg is a file or a directory to add (relative to $calling_dir)  
  msg "Validating files..."
  valid_paths=( )
  for file_arg in "${_arg_arg[@]}"; do
    file_path=$(get_path_rel_caller "$file_arg")
    if [ -f "${file_path}" ]; then
      
      ## make sure the file is not under .dotfiles path
      if isSubPath $dotfiles_dir $file_path ; then
        ## error
          msg2 "${file_path}" "${RED}Cannot stow file in .dotfiles"
        else
          msg2 "${file_path}" "OK"
          valid_paths+=( "$file_path" )
      fi
     
    else
      msg2 "${file_path}" "${RED}NOT FOUND"
      all_found=0
    fi
  done
  [[ $all_found -eq 0 ]] && die "Not all files were found, check paths!"
  
  msg ""
  msg "Moving files to stow repository: ${package_root}"
  msg ""

  ## critical part
  for file in "${valid_paths[@]}"; do
    stow_path=$(get_path_rel_package "${package_root}" "${file_path}")
        
    mv -n -- "${file}" "${stow_path}" || die "Move failed for $file"
    msg2 "${GREEN}Moved: $file" "-> $stow_path${NOFORMAT}"
  done
  
  

}


restow_single()
{
  #echo "stow -R -n --dir=${dotfiles_dir} --target=${target_dir} -S ${1} "
  ${stowcmd} -R --dir=${dotfiles_dir} --target=${target_dir} -S ${1} > /dev/null && msg2 "\t$1" "${GREEN}Updated${NOFORMAT}" || msg2 "$1" "Failed"
  sleep 0.1
}

restow()
{
  local force_all_pkgs
  force_all_pkgs=${RESTOW_ALL:-}
  ## this command requires package to be specified either using args och -p/--package
  local num_pkgs
  msg "Restoring ${GREEN}symlinks${NOFORMAT}" #. Packages=${_arg_arg[*]-all}...${NOFORMAT}"
  [[ -n "$force_all_pkgs" ]] && debug "forcing all packages"
  [[ -z "$_arg_package" ]] && debug "no package specified using -p"

  if [[ ( -z "${_arg_package}" && ${#_arg_arg[@]} -eq 0 ) || -n "$force_all_pkgs" ]]; then

    if [[ "no" == $(ask_yes_or_no "Re-apply all packages?") ]]
    then
        debug "Restow cancelled."; \
        return;
    fi
    
    subdir_list=$(find . -maxdepth 1 -not -path '*/\.*' -type d \( ! -iname ".*" \) -printf "%f ")
    
    num_pkgs=$(wc -w <<< "$subdir_list")
    echo "Found $num_pkgs packages:"
    for d in ${subdir_list}; do
      restow_single "$d"
    done 
  else
    if [ ${#_arg_arg[@]} -gt 0 ]; then
      debug "Restowing list of packages: ${_arg_arg[*]-}"
      for p in "${_arg_arg[@]}"; do
        restow_single "$p"
      done 
    else
      ## must be specified with -p/--package
      [[ -z "${_arg_package}" ]] && die "Error! Specify package with -p/--package or as a list (<arg-1..N>)"
      debug "Single packacke specified: $_arg_package"
      restow_single "${_arg_package}"
    fi
  fi
  
}

git_sync(){

  ## update remote status
  debug "git remote update \"${git_remote}\""
  nohup sh -c "git remote update \"${git_remote}\"" >&/dev/null & BG_PID="$!"
  
  #sleep 0.2
  
  ONLY_STATUS="ONLY_STATUS"
  MODE="${2:-SYNC}"
  debug "MODE: $MODE"

  debug "git status --porcelain=1 -uall"
  GIT_MODIFIED=$(git status --porcelain=1 -uall | awk '{print $1;}' | grep -E 'A|M|D' | head -1)
  GIT_UNTRACKED=$(git status --porcelain=1 -uall | awk '{print $1;}' | grep "?" | head -1)
  
  [ -n "$GIT_MODIFIED" ] && msg "${YELLOW}Modified${NOFORMAT} files in local"
  [ -n "$GIT_UNTRACKED" ] && msg "${RED}Untracked${NOFORMAT} files in local"

  ## Ask to commit files unless we are checking status only
  if [ "$MODE" != "$ONLY_STATUS" ]; then
    if [[ ( -n "$GIT_UNTRACKED" || -n "$GIT_MODIFIED" ) && "yes" == $(ask_yes_or_no "Commit with comment \"${_arg_arg[*]-auto commit}\"?") ]]; then      
      if [ "$MODE" != "$ONLY_STATUS" ]; then
        debug "git add --quiet"
        git add .
      fi      
      if [ "$MODE" != "$ONLY_STATUS" ]; then
        debug "git commit -m \"${_arg_arg[*]-auto commit}\" --quiet"
        git commit -m "${_arg_arg[*]-auto commit}" --quiet
      fi
    else
      debug "Commit declined by user"
    fi
  else
    msg "Run \`dot sync\` to commit local changes"
  fi
 
  

  ## Verify local vs remote HEAD versions
  UPSTREAM=${1:-'@{u}'}
  
  # LOCAL
  LOCAL=$(git rev-parse @)  
  [ "$MODE" == "$ONLY_STATUS" ] && msg "Local is at $LOCAL";

  debug "wait ${BG_PID}"
  wait ${BG_PID}

  # REMOTE
  REMOTE=$(git rev-parse "$UPSTREAM")  
  [ "$MODE" == "$ONLY_STATUS" ] && msg "Remote is at $REMOTE";

  # MERGE-BASE
  BASE=$(git merge-base @ "$UPSTREAM")

  debug "git rev-parse @ returned $LOCAL"
  debug "git rev-parse $1 returned $REMOTE"
  debug "git merge-base @ $1 returned $BASE"

  if [ $LOCAL = $REMOTE ]; then
      msg "Git is ${GREEN}up-to-date${NOFORMAT}"
  elif [ $LOCAL = $BASE ]; then
      ## do correct output when dry-run
      if [[ "$MODE" == "$ONLY_STATUS" && ( -n "$GIT_MODIFIED" || -n "$GIT_UNTRACKED" ) ]]; then 
        msg "Git need to ${YELLOW}pull${NOFORMAT} changes, and possibly rebase"
      else
        msg "Git need to ${YELLOW}pull${NOFORMAT} changes"
      fi
      if [ "$MODE" != "$ONLY_STATUS" ]; then
        pull_ff
      fi
  elif [ $REMOTE = $BASE ]; then
      msg "Git need to ${YELLOW}push${NOFORMAT} changes"
      if [ "$MODE" != "$ONLY_STATUS" ]; then
        push
      fi
  else
      msg "Git is ${RED}diverged${NOFORMAT} - doing a pull followed by a push"
      if [ "$MODE" != "$ONLY_STATUS" ]; then
        pull_rebase
        push
      fi
  fi

}
## deprecated
commit_changes()
{
 

  if [ -n "$(git status --porcelain)" ]; then
    debug "Changes detected, committing"
    git commit -m "${_arg_arg[*]-auto commit}" --quiet
    echo 1;
  else
    debug "No changes to commit";
    echo 0;
  fi
}
   
push()
{
  #args are all comments - merge to one string
  
  #has_changes=$(commit_changes)

  #if [[ $has_changes -eq 1 ]]; then
  msg "${GREEN}Pushing ${git_remote} ${git_branch}... (${_arg_arg[*]-auto commit})...${NOFORMAT}"
  git push "${git_remote}" "${git_branch}" --quiet
  debug "push done"
  #else
  #  msg "No changes to push"
  #fi

}

pull()
{ 
  
  msg "${GREEN}Pulling...${NOFORMAT}"
  PULL_MODE="${1:---ff-only}"
  debug "PULL_MODE: ${PULL_MODE}"
  #commit_changes

  debug "${BLUE}Stashing existing changes...${NOFORMAT}"
  stash_result=$(git stash push -m "dot: Before pulling git")
  needs_pop=1
  if [ "$stash_result" = "No local changes to save" ]; then
      debug "No local changes to save"
      needs_pop=0
  fi

  [ "${PULL_MODE}" == "--ff-only" ] && PULL_MODE_STR="Pulling updates" || PULL_MODE_STR="Fetching updates and rebasing";
  msg "${BLUE}${PULL_MODE_STR} from ${git_remote} ${git_branch}...${NOFORMAT}"
  git pull "${git_remote}" "${git_branch}" "${PULL_MODE}" --quiet --recurse-submodules; result=$?
  
  if [[ 0 != "${result}" ]]; then
    die "Pull failed with exit code ${result}. Try 'dot sync' instead which handles diverged branches"
  else
    debug "Pull exited with: ${result}"
  fi

  if [[ $needs_pop -eq 1 ]]; then
      debug "${BLUE}There are local changes, stashing them...${NOFORMAT}"
      git stash pop --quiet
  fi

  unmerged_files=$(git diff --name-only --diff-filter=U)
  if [[ -n $unmerged_files ]]; then
    msg "${RED}The following files have merge conflicts after popping the stash: ${NOFORMAT}"
    echo
    printf %"s\n" "$unmerged_files"  # Ensure newlines are printed
  fi 

}

pull_ff(){
  ## this can be omitted, as it is the default
  pull "--ff-only"
}

pull_rebase(){
  pull "--rebase"
}

reset()
{
  echo "${GREEN}Delete all symlinks using stow. Packages=${args[*]-all}...${NOFORMAT}"
  stow --dir="${dotfiles_dir}" --target="${target_dir}" -D
}

sync()
{

  git_sync "${git_remote}/${git_branch}"
  RESTOW_ALL=1 restow

}

self_update() {
    debug "${GREEN}Checking for newer version of dot...${NOFORMAT}"
    local INSTALLPATH="$HOME/.local/share/dot"
    pushd "$INSTALLPATH" > /dev/null || die "Could not install dir: $INSTALLPATH"

    timeout 2s git fetch --quiet

    timeout 2s git diff --quiet --exit-code "origin/main" "dot"
    [ $? -eq 1 ] && {
        debug "Found a new version of dot, updating..."
        git pull --force --quiet
        git checkout main --quiet
        git pull --force --quiet
        msg "${GREEN}dot${NOFORMAT} has been updated"
        popd > /dev/null || echo
        #exec "$SCRIPTNAME" "$@"

        # Now exit this old instance
        die "Update complete!"
    }
    msg "${GREEN}dot${NOFORMAT} is already up-to-date"
}

### Enter dotfiles directory by default
pushd "$dotfiles_dir" > /dev/null || die "Could not change directory"

### execute command
case $_arg_command in

  add)
    add
    ;;

  sync)
    sync
    ;;

  push)
    push
    ;;

  pull)
    pull
    ;; 

  restow)
    restow
    ;;  

  status)
    git_sync "${git_remote}/${git_branch}" "ONLY_STATUS"
    ;;

  update)
    self_update
    ;;     

  help)
    exit 0
    ;;     

  *)
    _PRINT_HELP=yes die "invalid command: $_arg_command";
    ;;
esac
 

debug "${GREEN} DONE ${NOFORMAT}"
#pushd -0 > /dev/null && dirs -c > /dev/null
popd > /dev/null || exit